# -*- coding: utf-8 -*-
"""CIFAR-10_Images_Classification.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18o2Vhp4NXCOFoK6JL3DA2datYk7EFguz

Importing the necessary python libraries
"""

import torch
import torchvision
import torchvision.transforms as Transforms
import torchvision.datasets as Datasets
import torch.utils.data as Data
import numpy as np
import matplotlib.pyplot as plt
import torch.nn as nn
import torch.nn.functional as F
import cv2

"""Firstly we define transforms for data augmentation. We will use HorizontalFlip and Normalize our data."""

transform = Transforms.Compose([
                              Transforms.RandomHorizontalFlip(),
                               Transforms.ToTensor(),
                               Transforms.Normalize((0.5,0.5,0.5),(0.5,0.5,0.5))])

transform1 = Transforms.Compose([
                               Transforms.ToTensor(),
                               Transforms.Normalize((0.5,0.5,0.5),(0.5,0.5,0.5))])

"""Now we get the CIFAR10 train and CIFAR10 test data"""

train_data = Datasets.CIFAR10(root = './data' , train = True , download = True, transform= transform)
test_data  = Datasets.CIFAR10(root = './data' , train = False , download = True , transform= transform1)

"""Now we will load our data using DataLoader. We will keep the batch size 50."""

train_loader = torch.utils.data.DataLoader(dataset = train_data, batch_size = 50 , shuffle = True)
test_loader = torch.utils.data.DataLoader(dataset = test_data, batch_size = 50 , shuffle = False)

"""We define a classes variable to classify images into different classes"""

classes =  ('airplane', 'automobile', 'bird', 'cat', 'deer', 'dog', 'frog', 'horse', 'ship',' truck' )

"""xxx"""

train_iter = iter(train_loader)
images,labels = train_iter.next()
print(images.shape)
print(images[0].shape)

"""Now let us look at the first few images of our dataset.First we need to change the shape to (32,32,3) which is the standard shape to display the image"""

fig,axs = plt.subplots(nrows = 1 , ncols= 10 , figsize = (12,12))

for img,i in zip(images,range(10)):
  np_img = img.numpy()
  np_img = np.transpose(np_img,(1,2,0))
  np_img = np_img*(0.5,0.5,0.5) + (0.5,0.5,0.5) 
  axs[i].imshow(np_img)
  axs[i].axis('off')
  axs[i].set_title(classes[labels[i]])
plt.show()

"""// All the ten classes have distinct shapes and thus we do not need colour to distinguish them.Thus making the images black and white will decrease the number of params"""

# Test converting images into b&w

"""// We can use histogram equalizer to standardize the background lighting"""

def equalize(img):
  img = cv2.equalizeHist(img)
  return img

"""Now let us design our model"""

class Net(nn.Module):

  def __init__(self):
    super(Net,self).__init__()
    self.conv1 = nn.Conv2d(in_channels = 3 , kernel_size=(3,3), stride = 1 , out_channels= 6 )
    self.conv2 = nn.Conv2d(in_channels = 6, out_channels = 16, kernel_size = (5,5), stride = 1) 
    self.pool = nn.MaxPool2d(kernel_size = (2,2), stride = 2, ceil_mode= True)
    self.fc1 = nn.Linear(in_features=16*6*6,out_features = 120)
    self.fc2 = nn.Linear(in_features = 120,out_features = 84)
    self.fc3 = nn.Linear(in_features=84 , out_features= 10)
    self.do = nn.Dropout(0.3)

  def forward(self,x):
   x = self.pool(F.relu(self.conv1(x)))
   x = self.pool(F.relu(self.conv2(x)))
   x = x.view(-1,16*6*6)
   x = F.relu(self.fc1(x))
   x = self.do(x)
   x = F.relu(self.fc2(x))
   x = self.do(x)
   x = self.fc3(x)

   return (x)

model = Net()
y = model(images)
print(y.shape)

"""We will define our loss function, our optimizer and the number of epochs"""

criteria = nn.CrossEntropyLoss()
optimizer = torch.optim.Adam(model.parameters(), lr=0.001,weight_decay=5e-4)
num_of_epochs = 30

"""We will initialize some lists that will help us plot our graphs"""

train_loss_list = []
train_accuracy_list = []
test_loss_list=[]
test_accuracy_list = []

"""Now we will define the training loop

"""

for epoch in range(num_of_epochs):

  train_loss = 0
  test_loss = 0
  total_trained = 0
  correct_trained = 0
  train_accuracy = 0
  total_tested = 0
  correct_tested = 0
  test_accuracy = 0 

  for image,label in train_loader:
   

   #forward pass
   train_pred = model(image)

   #calculating the loss
   loss = criteria(train_pred,label)

   #backward pass
   loss.backward()

   #changing weights
   optimizer.step()

   #emptying the gradient 
   optimizer.zero_grad()

   #now lets find the train accuracy and the train loss
   train_loss+= loss.item()

   _,train_pred = torch.max(train_pred,1)
   total_trained += label.size(0)
   correct_trained += train_pred.eq(label).sum().item()
 
   #displaying the loss for each epoch
  train_loss/= len(train_loader)
  train_accuracy = 100.*(correct_trained/total_trained)
  print(f'Epoch: {epoch+1} , Train Loss: {train_loss} , Train Accuracy: {train_accuracy}' ,  )
  
  
  

   #End of training

   #Now the test loop

  with torch.no_grad():  #we dont want to change our gradient when we test our data
     for image,label in (test_loader):
       
       test_pred = model(image)

       loss = criteria(test_pred,label)
       
       #now lets find the train accuracy and the Train loss
       
       test_loss+= loss.item()

       #  The shape of test_pred is (50,10) i.e. it has a classification score for each of the 10 categories.
       # The image belongs to the category with the maximum score.
       # We also need to then transform the tensor into a 1D tensor with shape (50) and the data must be the category.

      
       _,test_pred = torch.max(test_pred,1)
       total_tested += label.size(0)
       correct_tested += test_pred.eq(label).sum().item()
       

     # Displaying the loss for each epoch
     test_loss/= len(test_loader)
     test_accuracy = 100.*(correct_tested/total_tested)
     print(f'Epoch: {epoch+1} , Test Loss: {test_loss} , Test Accuracy: {test_accuracy}' ,  )
    
    #updating our lists

     train_loss_list.append(train_loss)
     test_loss_list.append(test_loss)
     train_accuracy_list.append(train_accuracy)
     test_accuracy_list.append(test_accuracy)

"""Now, we will plot the loss graph and the accuracy graph"""

#accuracy graph
plt.plot(train_accuracy_list, label ='Training Accuracy')
plt.plot(test_accuracy_list, label = 'Validation Accuracy')
plt.legend()

#loss graph
plt.plot(train_loss_list, label ='Training Loss')
plt.plot(test_loss_list, label = 'Validation loss')
plt.legend()